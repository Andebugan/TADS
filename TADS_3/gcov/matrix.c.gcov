        -:    0:Source:matrix.c
        -:    1:#include <stdlib.h>
        -:    2:#include <assert.h>
        -:    3:#include "status_codes.h"
        -:    4:#include "sparse_matrix.h"
        -:    5:
        -:    6:#define ASSERT_MAT(matrix)                                                                                                 \
        -:    7:    {                                                                                                                      \
        -:    8:        assert(matrix && "matrix cant be NULL");                                                                           \
        -:    9:        assert(matrix->data_array && matrix->data_cols && matrix->rows_array && "matrix is not initialized, but must be"); \
        -:   10:    }
        -:   11:
        -:   12:// проверка на принадлежность ненулевого элемента с индексом index
        -:   13:// строке с индексом row в разреженной матрице matrix
        -:   14:#define INDEX_IN_ROW(matrix, row, index) (matrix->rows_array[row] <= (index) && (index) < matrix->rows_array[row + 1])
        -:   15:
        -:   16:// проверка на принадлежность ненулевого элемента с индексом index
        -:   17:// столбцу с индексом col в разреженной матрице matrix
        -:   18:#define INDEX_IN_COL(matrix, col, index) (matrix->data_cols[index] == (col))
        -:   19:
        -:   20:// проверка на принадлежность ненулевого элемента с индексом index
        -:   21:// строке с индексом row и столбцу с индексом col в разреженной матрице matrix
        -:   22:#define INDEX_IN_POS(matrix, row, col, index) (INDEX_IN_ROW(matrix, row, index) && INDEX_IN_COL(matrix, col, index))
        -:   23:
        -:   24:// инициализирует нулевую матрицу для ручного заполнения
        5:   25:sp_mat_t sp_zero(mat_index_t rows, mat_index_t cols)
        -:   26:{
        -:   27:    sp_mat_t matrix;
        -:   28:
        5:   29:    matrix.rows = rows;
        5:   30:    matrix.cols = cols;
        5:   31:    matrix.nz_count = 0;
        -:   32:
        5:   33:    matrix.data_array = malloc(0);
        5:   34:    matrix.data_cols = malloc(0);
        5:   35:    matrix.rows_array = calloc(rows + 1, sizeof(mat_index_t));
        -:   36:
        5:   37:    return matrix;
        5:   37-block  0
        -:   38:}
        -:   39:
        -:   40:// очищает память из-под матрицы
        7:   41:void sp_free_mat(sp_mat_t *matrix)
        -:   42:{
        7:   43:    if (matrix->data_array != NULL)
        7:   43-block  0
        -:   44:    {
        7:   45:        free(matrix->data_array);
        7:   46:        matrix->data_array = NULL;
        -:   47:
        7:   48:        free(matrix->data_cols);
        7:   49:        matrix->data_cols = NULL;
        -:   50:
        7:   51:        free(matrix->rows_array);
        7:   52:        matrix->rows_array = NULL;
        7:   52-block  0
        -:   53:    }
        7:   54:}
        -:   55:
        -:   56:// получает конкретный элемент по индексам
       25:   57:mat_data_t sp_get(sp_mat_t *matrix, mat_index_t row, mat_index_t col)
        -:   58:{
      25*:   59:    ASSERT_MAT(matrix);
       25:   59-block  0
    %%%%%:   59-block  1
       25:   59-block  2
       25:   59-block  3
       25:   59-block  4
    %%%%%:   59-block  5
       25:   60:    mat_index_t nz_index = matrix->rows_array[row];
       25:   61:    mat_index_t nz_last = matrix->rows_array[row + 1];
        -:   62:
       44:   63:    while (nz_index < nz_last && matrix->data_cols[nz_index] < col)
       25:   63-block  0
       44:   63-block  1
       39:   63-block  2
       19:   64:        nz_index++;
       19:   64-block  0
        -:   65:
       25:   66:    if (nz_index < nz_last && matrix->data_cols[nz_index] == col)
       25:   66-block  0
       20:   66-block  1
       17:   67:        return matrix->data_array[nz_index];
       17:   67-block  0
        -:   68:    else
        8:   69:        return 0;
        8:   69-block  0
        -:   70:}
        -:   71:
        -:   72:// устанавливает конкретный элемент по индексам
       13:   73:void sp_set(sp_mat_t *matrix, mat_index_t row, mat_index_t col, mat_data_t value)
        -:   74:{
      13*:   75:    ASSERT_MAT(matrix);
       13:   75-block  0
    %%%%%:   75-block  1
       13:   75-block  2
       13:   75-block  3
       13:   75-block  4
    %%%%%:   75-block  5
        -:   76:
       13:   77:    mat_index_t nz_index = matrix->rows_array[row];
       13:   78:    mat_index_t nz_last = matrix->rows_array[row + 1];
        -:   79:
       17:   80:    while (nz_index < nz_last && matrix->data_cols[nz_index] < col)
       13:   80-block  0
       17:   80-block  1
        4:   80-block  2
        4:   81:        nz_index++;
        4:   81-block  0
        -:   82:
      13*:   83:    if (nz_index < nz_last && matrix->data_cols[nz_index] == col)
       13:   83-block  0
    %%%%%:   83-block  1
    #####:   84:        matrix->data_array[nz_index] = value;
    %%%%%:   84-block  0
        -:   85:    else
        -:   86:    {
       13:   87:        matrix->nz_count++;
       13:   88:        matrix->data_array = realloc(matrix->data_array, matrix->nz_count * sizeof(mat_data_t));
       13:   89:        matrix->data_cols = realloc(matrix->data_cols, matrix->nz_count * sizeof(mat_data_t));
       13:   89-block  0
        -:   90:
        -:   91:        mat_data_t temp_elem;
        -:   92:        mat_index_t temp_col;
        -:   93:
        -:   94:        do
        -:   95:        {
       13:   96:            temp_elem = matrix->data_array[nz_index];
       13:   97:            temp_col = matrix->data_cols[nz_index];
        -:   98:
       13:   99:            matrix->data_array[nz_index] = value;
       13:  100:            matrix->data_cols[nz_index] = col;
        -:  101:
       13:  102:            value = temp_elem;
       13:  103:            col = temp_col;
        -:  104:
       13:  105:            nz_index++;
        -:  106:        }
       13:  107:        while (nz_index < matrix->nz_count);
       13:  107-block  0
        -:  108:
        -:  109:        // обновить список индексов строк
       36:  110:        while (row++ < matrix->rows)
       13:  110-block  0
       36:  110-block  1
       23:  111:            matrix->rows_array[row]++;
       23:  111-block  0
        -:  112:    }
       13:  113:}
        -:  114:
        -:  115:// удаление нулевых элементов из матрицы
        2:  116:void sp_zip(sp_mat_t *matrix)
        -:  117:{
       2*:  118:    ASSERT_MAT(matrix);
        2:  118-block  0
    %%%%%:  118-block  1
        2:  118-block  2
        2:  118-block  3
        2:  118-block  4
    %%%%%:  118-block  5
        -:  119:
        2:  120:    mat_index_t z_count = 0;
        2:  121:    mat_index_t row = 0;
        4:  122:    for (mat_index_t nz_index = 0; nz_index + z_count < matrix->nz_count; nz_index++)
        2:  122-block  0
        4:  122-block  1
        -:  123:    {
        -:  124:        // при переходе на следующую строку удаляем из строки все нулевые
        2:  125:        while (matrix->rows_array[row + 1] <= nz_index + z_count)
        2:  125-block  0
        2:  125-block  1
    #####:  126:            matrix->rows_array[++row] -= z_count; 
    %%%%%:  126-block  0
        -:  127:
        2:  128:        if (matrix->data_array[nz_index] == 0) // наш клиент
        2:  128-block  0
    #####:  129:            z_count++;
    %%%%%:  129-block  0
        -:  130:
        2:  131:        matrix->data_array[nz_index] = matrix->data_array[nz_index + z_count];
        2:  132:        matrix->data_cols[nz_index] = matrix->data_cols[nz_index + z_count];
        2:  132-block  0
        -:  133:    }
        -:  134:
        -:  135:    // при переходе на следующую строку удаляем из строки все нулевые
        6:  136:    while (row < matrix->rows + 1)
        2:  136-block  0
        6:  136-block  1
        4:  137:        matrix->rows_array[++row] -= z_count; 
        4:  137-block  0
        -:  138:
        2:  139:    matrix->nz_count -= z_count;
        2:  140:    matrix->data_array = realloc(matrix->data_array, matrix->nz_count * sizeof(mat_data_t));
        2:  141:    matrix->data_cols = realloc(matrix->data_cols, matrix->nz_count * sizeof(mat_data_t));
        2:  142:}
        -:  143:
        -:  144:// транспозиция матрицы на месте
        2:  145:void sp_transpose(sp_mat_t *matrix)
        -:  146:{
        -:  147:    sp_mat_t new_mat;
        2:  148:    new_mat.rows = matrix->cols;
        2:  149:    new_mat.cols = matrix->rows;
        2:  150:    new_mat.nz_count = matrix->nz_count;
        -:  151:
        2:  152:    new_mat.data_array = malloc(new_mat.nz_count * sizeof(mat_data_t));
        2:  153:    new_mat.data_cols = malloc(new_mat.nz_count * sizeof(mat_index_t));
        2:  154:    new_mat.rows_array = malloc((new_mat.rows + 1) * sizeof(mat_index_t));
        -:  155:
        2:  156:    mat_index_t new_nz_index = 0;
        2:  157:    new_mat.rows_array[0] = 0;
        8:  158:    for (mat_index_t col = 0; col < matrix->cols; col++)
        2:  158-block  0
        8:  158-block  1
        -:  159:    {
       30:  160:        for (mat_index_t nz_index = 0; nz_index < matrix->nz_count; nz_index++)
        6:  160-block  0
       24:  160-block  1
       30:  160-block  2
        -:  161:        {
       24:  162:            if (INDEX_IN_COL(matrix, col, nz_index))
       24:  162-block  0
        -:  163:            {
        -:  164:                // выяснить индекс строки в старой матрице
        8:  165:                mat_index_t row = 0;
       15:  166:                while (!INDEX_IN_ROW(matrix, row, nz_index))
        8:  166-block  0
       15:  166-block  1
       15:  166-block  2
        7:  167:                    row++;
        7:  167-block  0
        -:  168:
        -:  169:                // записать этот элемент в транспонированную матрицу
        8:  170:                new_mat.data_array[new_nz_index] = matrix->data_array[nz_index];
        8:  171:                new_mat.data_cols[new_nz_index] = row;
        8:  172:                new_nz_index++;
        8:  172-block  0
        -:  173:            }
        -:  174:        }
        -:  175:
        6:  176:        new_mat.rows_array[col + 1] = new_nz_index;
        6:  176-block  0
        -:  177:    }
        -:  178:
        2:  179:    free(matrix->data_array);
        2:  180:    free(matrix->data_cols);
        2:  181:    free(matrix->rows_array);
        2:  182:    *matrix = new_mat;
        2:  183:}
        -:  184:
        -:  185:// умножение вектора-строки на матрицу (обычный метод)
        1:  186:int sp_mult_vector_slow(sp_mat_t *output, sp_mat_t *vector, sp_mat_t *matrix)
        -:  187:{
        1:  188:    int status = SUCCESS;
       1*:  189:    ASSERT_MAT(vector);
        1:  189-block  0
    %%%%%:  189-block  1
        1:  189-block  2
        1:  189-block  3
        1:  189-block  4
    %%%%%:  189-block  5
       1*:  190:    ASSERT_MAT(matrix);
        1:  190-block  0
    %%%%%:  190-block  1
        1:  190-block  2
        1:  190-block  3
        1:  190-block  4
    %%%%%:  190-block  5
        -:  191:
       1*:  192:    assert(vector->rows == 1 && "given matrix is not row-vector");
        1:  192-block  0
    %%%%%:  192-block  1
        -:  193:
        -:  194:    // проверка на возможность умножить вектор на матрицу
        1:  195:    if (vector->cols != matrix->rows)
        1:  195-block  0
    #####:  196:        status = BAD_MAT_DIMS;
    %%%%%:  196-block  0
        -:  197:    else
        -:  198:    {
        -:  199:        // создать матрицу под произведение
        1:  200:        output->rows = 1;
        1:  201:        output->cols = matrix->cols;
        1:  202:        output->data_array = calloc(matrix->cols, sizeof(mat_data_t));
        1:  203:        output->data_cols = malloc(matrix->cols * sizeof(mat_index_t));
        1:  204:        output->rows_array = malloc(2 * sizeof(mat_index_t));
        -:  205:
        -:  206:        // индекс текущего обрабатываемого элемента матрицы - он же индекс столбца
        4:  207:        for (mat_index_t col = 0; col < output->cols; col++)
        1:  207-block  0
        3:  207-block  1
        4:  207-block  2
        -:  208:        {
        -:  209:            // настройка индексов столбцов у элементов
        3:  210:            output->data_cols[col] = col;
        -:  211:
       12:  212:            for (mat_index_t row = 0; row < matrix->rows; row++)
        3:  212-block  0
       12:  212-block  1
        9:  213:                output->data_array[col] += sp_get(vector, 0, row) * sp_get(matrix, row, col);
        9:  213-block  0
        -:  214:        }
        -:  215:
        -:  216:        // начало и конец первой и единственной строки
        1:  217:        output->rows_array[0] = 0;
        1:  218:        output->rows_array[1] = output->cols + 1;
        -:  219:
        1:  220:        sp_zip(output);
        1:  220-block  0
        -:  221:    }
        -:  222:
        1:  223:    return status;
        1:  223-block  0
        -:  224:}
        -:  225:
        -:  226:// умножение вектора-строки на матрицу (эффективный метод)
        1:  227:int sp_mult_vector_fast(sp_mat_t *output, sp_mat_t *vector, sp_mat_t *matrix)
        -:  228:{
        1:  229:    int status = SUCCESS;
       1*:  230:    ASSERT_MAT(vector);
        1:  230-block  0
    %%%%%:  230-block  1
        1:  230-block  2
        1:  230-block  3
        1:  230-block  4
    %%%%%:  230-block  5
       1*:  231:    ASSERT_MAT(matrix);
        1:  231-block  0
    %%%%%:  231-block  1
        1:  231-block  2
        1:  231-block  3
        1:  231-block  4
    %%%%%:  231-block  5
        -:  232:
       1*:  233:    assert(vector->rows == 1 && "given matrix is not row-vector");
        1:  233-block  0
    %%%%%:  233-block  1
        -:  234:
        -:  235:    // проверка на возможность умножить вектор на матрицу
        1:  236:    if (vector->cols != matrix->rows)
        1:  236-block  0
    #####:  237:        status = BAD_MAT_DIMS;
    %%%%%:  237-block  0
        -:  238:    else
        -:  239:    {
        -:  240:        // создать матрицу под произведение
        1:  241:        output->rows = 1;
        1:  242:        output->cols = matrix->cols;
        1:  243:        output->data_array = calloc(matrix->cols, sizeof(mat_data_t));
        1:  244:        output->data_cols = malloc(matrix->cols * sizeof(mat_index_t));
        1:  245:        output->rows_array = malloc(2 * sizeof(mat_index_t));
        -:  246:
        -:  247:        // транспонировать исходную матрицу
        1:  248:        sp_transpose(matrix);
        1:  248-block  0
        -:  249:
        -:  250:        // индекс текущего обрабатываемого элемента матрицы - он же индекс столбца
        4:  251:        for (mat_index_t nz_index = 0; nz_index < output->cols; nz_index++)
        4:  251-block  0
        -:  252:        {
        -:  253:            // настройка индексов столбцов у элементов
        3:  254:            output->data_cols[nz_index] = nz_index;
        -:  255:
        -:  256:            // предустановка индексов для обхода
        3:  257:            mat_index_t nz_mat_index = matrix->rows_array[nz_index];
        3:  258:            mat_index_t nz_vec_index = 0;
        3:  259:            mat_index_t nz_mat_index_end = matrix->rows_array[nz_index + 1];
        3:  260:            mat_index_t nz_vec_index_end = vector->nz_count;
        -:  261:
        3:  262:            mat_data_t sum = 0;
        -:  263:
        -:  264:            // пока не дошли до конца хотябы одной из строк матриц
        7:  265:            while (nz_mat_index < nz_mat_index_end && nz_vec_index < nz_vec_index_end)
        3:  265-block  0
        7:  265-block  1
        4:  265-block  2
        -:  266:            {
        -:  267:                // находим ближайшую пару индексов nz_vec_index и nz_mat_index с одинаковыми индексами столбцов
       10:  268:                while (vector->data_cols[nz_vec_index] < matrix->data_cols[nz_mat_index])
        4:  268-block  0
       10:  268-block  1
        6:  269:                    nz_vec_index++;
        6:  269-block  0
        -:  270:
       13:  271:                while (vector->data_cols[nz_vec_index] > matrix->data_cols[nz_mat_index])
        4:  271-block  0
       13:  271-block  1
        9:  272:                    nz_mat_index++;
        9:  272-block  0
        -:  273:
        -:  274:                // если нашли, добавляем произведение к сумме и увеличиваем оба индекса
        4:  275:                if (nz_vec_index < nz_vec_index_end && nz_mat_index < nz_mat_index_end && vector->data_cols[nz_vec_index] == matrix->data_cols[nz_mat_index])
        4:  275-block  0
        3:  275-block  1
        3:  275-block  2
        3:  276:                    sum += vector->data_array[nz_vec_index] * matrix->data_array[nz_mat_index];
        3:  276-block  0
        -:  277:
        4:  278:                nz_vec_index++;
        4:  279:                nz_mat_index++;
        4:  279-block  0
        -:  280:            }
        -:  281:
        3:  282:            output->data_array[nz_index] = sum;
        3:  282-block  0
        -:  283:        }
        -:  284:
        -:  285:        // начало и конец первой и единственной строки
        1:  286:        output->rows_array[0] = 0;
        1:  287:        output->rows_array[1] = output->cols + 1;
        -:  288:
        1:  289:        sp_zip(output);
        1:  289-block  0
        -:  290:
        -:  291:        // транспонировать исходную матрицу обратно
        1:  292:        sp_transpose(matrix);
        -:  293:    }
        -:  294:
        1:  295:    return status;
        1:  295-block  0
        -:  296:}
